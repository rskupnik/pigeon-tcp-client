{
  "name": "Pigeon TCP Client",
  "tagline": "Pigeon is a small library for packet transmission for Java",
  "body": "# What is it?\r\n\r\nPigeon is a small library for packet transmission for Java. This module handles the client side of a TCP connection.\r\n\r\n# How to use it?\r\n\r\nYou build a PigeonTcpClient like so:\r\n\r\n```\r\nPigeonTcpClient client = Pigeon.newClient()\r\n    .withHost(\"localhost)\r\n    .withPacketHandler(new PacketHandler() {\r\n        @Override\r\n        public void handle(Packet packet) {\r\n\r\n        }\r\n    })\r\n    .build();\r\n    \r\nclient.connect();\r\n```\r\n\r\nAnd at this point Pigeon will attempt a connection to localhost at the default port. Provided in the example are minimal required parameters for Pigeon to work - host and packet handler. The rest will be set to defaults.\r\n\r\nHere are all the possible configuration options:\r\n\r\n```\r\nPigeon.newClient()\r\n    .withHost(\"localhost\")                                          // Defaults to null which will cause an error\r\n    .withPort(9191)                                                 // Defaults to 9191\r\n    .withIncomingPacketHandleMode(IncomingPacketHandleMode.HANDLER) // Defaults to HANDLER - see below for more options\r\n    .withPacketHandler(new PacketHandler() {                        // Required when incoming packet mode is HANDLER\r\n        @Override\r\n        public void handle(Packet packet) {\r\n\r\n        }\r\n    })\r\n    .withClientCallbackHandler(clientCallbackHandler)               // Not required, no default\r\n    .withPackageToScan(\"com.github.rskupnik\")                       // Not required, defaults to null which will cause the entire classpath to be scanned\r\n    .withPropertiesFilename(\"my-properties.properties\")             // Points the properties file to load, by default searched for pigeon-tcp-client.properties\r\n    .build();\r\n```\r\n\r\nMost of these can be provided in a properties file. By default, PigeonTcpClient will look for a pigeon-tcp-client.properties file\r\neither on the classpath or in the project's root folder. You can point to another properties file, however, using the\r\n`withProperties()` builder option - Pigeon will then look for that filename on the classpath or in the project's root folder.\r\n\r\nHere's how a configuration file looks like:\r\n\r\n```\r\nhost=localhost\r\nport=9192\r\npackage_to_scan=com.github.rskupnik.pigeon.tcpserver\r\npacket_handle_mode=handler\r\n```\r\n\r\nThe precedence is as follows:\r\n\r\n`manual_input -> configuration_file -> defaults`\r\n\r\nWhich means that Pigeon will first look for configuration values provided manually (by using the `.withXXX()` builder methods) and, if not found, fall back to configuration file and then to default values in case the file is not present as well.\r\n\r\n## Handling packets\r\n\r\nPigeon makes use of annotations to describe packets for sending and receiving.\r\nA valid packet class must conform to these rules:\r\n* Be public\r\n* Extend the `Packet` class\r\n* Be annotated with `@PigeonPacket` (with id provided)\r\n* Have proper getter and setter methods for any variables that should be a part of the packet (annotated with `@PacketDataField`)\r\n\r\n```\r\n@PigeonPacket(id = 1)\r\npublic class TestPacket extends Packet {\r\n\r\n    @PacketDataField\r\n    private int testData;\r\n\r\n    public int getTestData() {\r\n        return testData;\r\n    }\r\n\r\n    public void setTestData(int testData) {\r\n        this.testData = testData;\r\n    }\r\n}\r\n```\r\n\r\nThese packet classes should reside in a single package and Pigeon should be told which package to scan for them (using either\r\nthe configuration file or the `withPackageToScan()` builder method). Pigeon will still work if not provided with the package name\r\nto scan but will initialize much, much slower because it will have to scan the entire classpath.\r\n\r\n### Sending packets\r\n\r\nOnce the packet has been created and found by Pigeon, it can be easily sent using the `.send()` method on the client.\r\n\r\n```\r\nTestPacket packet = new TestPacket();\r\npacket.setTestData(8);\r\n\r\n// Assume we have a properly initiated PigeonTcpClient under the variable 'client' here\r\nclient.send(packet);\r\n```\r\n\r\n### Receiving and handling packets\r\n\r\nWhen receiving packets, Pigeon identifies them using the id value provided in the `@PigeonPacket` annotation, so it's very important\r\nto not have overlapping ids.\r\n\r\nOnce a packet is received, there are two modes for handling it - these can be set using the configuration file or\r\nthe `.withIncomingPacketHandleMode()` builder method.\r\n\r\nThe default mode - HANDLER - will make a callback to the handler function you must provide when initializing the client:\r\n\r\n```\r\nPigeon.newClient()\r\n    .withHost(\"localhost)\r\n    .withPacketHandler(new PacketHandler() {\r\n        @Override\r\n        public void handle(Packet packet) {\r\n          if (packet.getId() == 1) {\r\n            TestPacket testPacket = (TestPacket) packet;\r\n            // Handle the packet...\r\n          }\r\n        }\r\n    })\r\n    .build();\r\n```\r\n\r\nThe other mode - QUEUE - will put the packet into a queue once it is received. At this point Pigeon stops caring about it,\r\nit's your task to poll the queue periodically and handle the packets.\r\n\r\n```\r\nPigeonTcpClient client = Pigeon.newClient()\r\n    .withHost(\"localhost)\r\n    .withIncomingPacketHandleMode(IncomingPacketHandleMode.QUEUE)\r\n    .build();\r\n    \r\nclient.connect();\r\n    \r\n// Do this periodically in a separate thread\r\nList<Packet> packets = client.getIncomingPacketQueue().popAll();\r\nfor (Packet packet : packets) {\r\n  if (packet.getId() == 1) {\r\n    TestPacket testPacket = (TestPacket) packet;\r\n    // Handle the packet...\r\n  }\r\n}\r\n```\r\n\r\n## Callbacks\r\n\r\nYou can provide Pigeon with a callback handler if you want to receive callbacks when specific things happen.\r\n\r\n```\r\nclass TestClientCallbackHandler implements ClientCallbackHandler {\r\n\r\n    @Override\r\n    public void onConnected() {\r\n\r\n    }\r\n}\r\n\r\nPigeonTcpClient client = Pigeon.newClient()\r\n    .withHost(\"localhost)\r\n    .withIncomingPacketHandleMode(IncomingPacketHandleMode.QUEUE)\r\n    .withClientCallbackHandler(new TestClientCallbackHandler())\r\n    .build();\r\n```\r\n\r\nCurrently, PigeonTcpClient only provides callback for the `onConnected` event.\r\n\r\n### Rationale\r\n\r\nI've found myself often in need of a simple library for handling packet communication in Java. Available libraries\r\nwhere usually too complex and rewriting the same custom code in each hobby project was tedious. I've created Pigeon to \r\nbe able to implement packet communication quickly and be able to define new packets easily - with annotations and \r\nno wiring required.\r\n\r\nPigeon does not aim to be the most performant, the most configurable or the safest packet handling library out there. It rather aims\r\nto be simple, easy to use and pick up. Therefore, it is mostly suitable for small hobby projects.\r\n\r\n### Future\r\n\r\n* Handle more data types than just integer and string\r\n* Add support for SSL encryption?\r\n* Perhaps other incoming packet handle modes?\r\n* More callback functions\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}